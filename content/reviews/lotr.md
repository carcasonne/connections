+++
   title = "My Review Title"
   date = 2023-04-18
   [extra]
   author = "Your Name"
+++

# Other Writings

OS: Void Linux
What Arch Linux purports to be, minimal, is more so achieved by Void Linux. No systemd⸻need I say more? The bestest package management system. And it comes in both yucky, gunky glibc and musl C standard library flavors. I'd used Xubuntu for 1⸺2y ~201[456], but had switched back to win7 due to constant issues (what with I cannot remember). I hadn't then the tenacity to problemsolve, nor the time or willingness to learn to. 1⸺1.5y before switching, I'd fucked-, no, stabwoundfucked my installation by half-assedly, mischievously, unthoughtfully registry-editing, causing boot-up to last a measly 25'. Rummaging round there shortly before doing the deed, I deleted vast amounts superfluous records, which too little, too late fixed the issue. The 'fast', read 2', boot was back, yey..? Happy-go-lucky me chose to forgo decision and take the plunge of switching before variegate other ugliness sprang up. My first void install was with the Enlightenment DE, a.k.a. crashmedadDE, but in 2⸺3 months after reacquaintance with GNU/Linux, I did a reinstall without a DE, taking the suckless pill. Very happy with just about everything.

Shell: zsh
Everything about it I love (Too strong a word? My firm discontentment with bash, and less so (da)sh necessitates a push toward one extremum.)⸻globbing, recursion, flags and modifiers, loop shorthands, modules, PCRE, options galore, emulate of all the major shells, arrays, PCRE!!!, and more. Read all ~210000 words or ~32000 80-width lines of the fucking documentation. Additional resources in no particular order: zsh refcard (useful although slightly outdated), grml, zsh mailing list, rayninfo zshtips.

Window manager: dwm
Small, fast, stable, easily extensible; pairs well with slstatus, what I used, and setroot, both likewise. Ages ago I used herbstluftwm with conky, and dzen2; configuration of all of which was unnecessarily clunky, also bloat. I use the hide-vacant-tags, columns, push-no-master, smart-borders patches.

Terminal emulator: st
Small, fast, stable, easily extensible. I use the ligatures, scrollback, and ringbuffer patches. Low input latency, memory usage. Does the job.

Text editor: kakoune
Chronologically, I omit notepad.exe (bc. fuck MS, fuck .rtf's, and bloat), Sublime Text was my first big boy text editor, used 2011⸺2021. Sane settings, sane keybindings (coming from Windows, that is); rather easily and verily customizable. Bundled with a package manager, that "just werks", and packages abound. Present day, since the closed-source aussie cunts don't offer statically linked or musl builds, I've had to give quite literally every text editor found in my disto's repo, and then some, an honest shake. And the aforementioned them some come from github, gitlab, codeberg, sourcehut, and so on. Usually, when something runs smoothly, You don't have much to say, You are content (or You're in awe and exult, if it's actually good). When it don't le just werk⸻oof.
A (very) non-exhaustive listing of shit: dte and mle⸻both a chore to use, being mildly-to-roilingly obtuse to configure. sandy⸻too simple, lacked bindings, amidst other now forgotten reasons. lime⸻never got working. slap⸻more or less the same, albeit worse because JS. emacs⸻just no. Obtuse and abstruse, and bindings are for the M in S&M-fans, how in the fuck is more keypresses good, let alone better, for You (or anybody else)?! vi(m)⸻begrudgingly usable with much rebinding, reading, head-scratching, and experimenting alongside patience. Learning everything, then shuffling and juggling configs and mappings to something familiar will durate coming from anything Windows-y (exactly why emacs feels like it does). Obviously moribund, evidenced by the extended life-support proffered by neovim and Lua. Even disregarding the many, for a "normal" user, cryptic, unhelpful error messages, that one gets when trying to do something, one can at least get some work done. zed is written in a tranny language by the fuckers at jewgle. So very likely trash, until I get a binary without installing a language and its shit package manager, I'm passing. zed, zsh's editor, partnered with fast-syntax-highlighting (and kakoune rebindings, also edited because incomplete and haphazardly) is splendid for anything shell-related under 10kb (when the lag from fsh starts annoying). ed, ex, acme, sam, and joe, amidst other antiquties, I'd put besides emacs⸻lepers. lite-xl is another Lua-based one. Easy to write plugins for (probably more so than neovim), as well as much prettier and with sane-r default keybs. kakoune does everything I want of it: good choice of regex though not Perl-compatible; snappy; sane defaults. helix is almost great. Well, not 'almost', but it did some stuff in the right direction for all the wrong reasons, with the wrong goals, and bad spirit, and bad 'toxic' community/users/devs. *sigh* I dislike its modal paradigm, to start off. It should be kept as simple as possible, rather than adding modes willy-nilly. At least 2 of its can be outright slashed (Selection mode..? Append mode, which is not insert mode..? Why?! Why not just call every command a mode?) by using alt/super (or any other modifier or, any other key as a modifier), which it by design disallows. So, it's a much, much less customizable than vim/kakoune, with much less the functionality. I couldn't for 30' rebind selection mode's modified h, j, k, l keybs to the ones I used in kakoune, which are WORD by default. Very fiddley and clunky. But hey, being integrated with tree-shitter is a big giant plus for normies and other smoothbraineds. Which is also why it's triple the star count on github despite, as of writing, being only 4 years in age, versus the 13 of kak . You can't write Your own syntax files neither quickly, nor simply⸻You must use treeshitter. *sigh* Kakoune which abides by the UNIX philosophy is taken up by 'hackers', supposedly, allegedly, people ready and willing to put in the time and effort to understand and customize, to make the program to their work, rather than have it call another upteen programs to slow defecate a grotesque of a result. No plugins, no integration with *NIX by design, limited scope and unextendable. Does exactly one thing, and I mentioned it last, as I don't see value in it. A mess. Shit language, too.

Pager: less
There are exactly two pagers that predominate the GNU/Linux distros: more and less. All my reading is accomplished through it. It uses PCRE, render ANSI C escape code, is rebindable, and customizable; allows piping and editing. Probably my most used program, not counting the shell, terminal emulator, tabbed, and window manager.

File browser manager: noice, clifm
Fast, in C, and extensible, if You're into reinventing or improving existing code. Functionality is minimal, has more aesthetic qualities. Not bug-ridden or slow as ranger, nor as finicky as lf. Rarely do I use it or need a visual representation of files. clifm is like shell on HGH and roids for doing file stuff without obsolescing selection programs or find-type programs' (batch) execution option. Even more customizable than noice through rc files (ini) and shell scripts; it's also written in C.

Music player: mpd, mpv
Dicking around for several hours-to-days with ncmpcpp is the closest thing to foobar2000, which is still the undisputed godkingemperor of players. *nix users supposedly often run it through wine. These two are stable, reliable, quick, easily configurable, have terminal user interface, and support online radio stuff. The cover art thing is annoying...

Media player: mpv
Cosmic amount of settings, if You're into that shit. I'm not. Does the job out of the box though. Nice integration with yt-dlp and ffmpeg, relegating using shitty, 'modern' websites' JS players or browsers themselves as media players.

Internet browser: boredserf, vimb, elinks, librewolf
boredserf is a fork of surf, that majorly added a uBlock-like way of allowing and or blocking types of resources from first and or third parties. Compared to surf, it's better. I couldn't port the userscript plugin, because I no smart, so I continue using it for 4chanX and imageboards. With Firefox, which I'd used prior to unaddressable issues popping up, that weren't encountered by anybody else online publicly, for over 1.5y as of the IW date, relating to persistent: scroll-jitter, tab-crashing (of all), and privacy. Anyway, I'm very happy to have contacted Jon Bakke, who'd written a patch for content blocking for surf. After some back and forth with me, he got to forking surf. I think he has abandoned it, given the lack of updates. Anyway, with two small tweaks to the source, nothing throttles, lags, crashes, or freezes on my end, so I'm mostly content (compared to surf). For surf, I have keybound surfraw (some of whose elvi are out of date, but most easily fixable) as additional dmenu prompt, and used only the aforementioned patch to facilitate imageboard-usage. The lack of uBlockOrigin can be partially offset by wyebadblock supposedly, though I never got it to work (properly). Additionally, sort -uing some big-ish lists of elements to hide (concatenate easylist, easyprivacy, fanboy-(social|annoyance|cookiemonster) antiadblockfilters, etc.), and append to the default stylesheet, one gets decent results, alongsite a big /etc/hosts file. elinks has the 'benefit' of not being able deal with javascript, or any 'modern' web bullshit. User-provided stylesheets have the desired effect because the terminal doesn't change its colors and backgrounds, yielding the exact same style for every website⸻no to-n-fro css switching and fiddling⸻and being faster to load anything, because many of them cannot be handled. For reference material, (simple) fora, and plain text reading, it beat the rest by a country mile. Librewolf I installed after installing the flatpak for MuseScore4. Concurrency and or parallelism are vimb, surf/boredserf, and nyxt's greatest bottleneck. The difficulty of tailoring anything is noticeable. Its speed is its only grace.

PDF viewer: zathura, sioyek, qpdfview
The lightest one that's easily customizable, not an eyesore, and doesn't leak memory. Glaring at You, katarakt. mupdf (memory-heavy, single-file, no xid), xpdf, xreader, apvlv can eat donkey dick. The --unique option of qpdfview requires dbus, which I do not want (to touch). zathura with tabbed is a patchwork. It has some issues: lag-ready and -prone, like vimb, which is also undiagnosable; requires a refresh of sorts, what I do is select the same tab. Higher zoom level calculate really slowly. Otherwise minimal and decent. Sioyek hasn't integration with the X and or prefers to not utilize so called 'tabs'. It also has obtuse keybindings and defaults. It therefore is least useful.

Image viewer: sxiv, feh
feh achieves a bit more than its competitors⸻as a background-setter, can sort according to image parameters, etc. like nearly 2y After awhiles, I've finally gotten round to sxiv, and I really like it. Regarding terminal graphics programs, chafa is the best (fastest, highest quality, on my machine, at least). I'd tried 3 others (1 forgotten)⸻tiv better than caca. I have nox versions for pretty much everything I use, ha-ha...

Torrent client: qbittorrent, transmission
I can't remember my gripe with the every client my repo offers, so I'll just emit what I recall: qbittorrent suddenly started segfaulting in mid-2021 (worked in 2023 spring when transmission decided to stop working), though it was nearly perfect; rtorrent has abstruse keybindings, inexcusable performance, and usability, stability, and development issues. mabel and a few Go ones have popped up, but neither has the polish of these.
misc

Spritz reader: speedread
When reading something inconsequential, or containing less than, say, 4000 words, with little-to-no valuable information or heavy sentences (uncommon and or long words, uncommon or weird wording and phrasing, among others), this tool allows express consumption, that is, reading. fltrdr, flinks, cfastread are a few of the better ones other there, the first two having some capabilities for aesthetics, and the last having no controls currently. Most, that I've tried from github, have issues, be it keybindings, bad design, overextension/scope creep. I wanted something that was similar to Balabolka's spritz reader, which introduced me to the idea first. In the end, I modified a good Perl script named speedread. Highly recommended for fodder articles.

HTML parser: pup
Lovely tool. The virgin API vs. the Chad scrape and so on and so forth. Most my scripts for dealing with websites from the command line use it.

HTML reader: rdrview
Built in C from Mozilla's Firefox's reader's code. Using a browser, put elinks here, it processes any .html file, extracting what it considers essential content, and opens result in browser. Or if You use a -dump(-like) option, You get plaintext. Viewable in a pager. All RSS items (entries?) that contain text are passed through, giving the selfsame reading experience for all html files, rather than possibly necessitating context-switching and not focusing on, that is, distracting Yourself from the wildly different designs of websites. Also, insert 'The virgin API vs. the Chad scrape' meme.

Doc prep: tectonic
Since learning LaTeX in uni, I've used it for CV, diabetes logbook, personal dictionaries, documentation, letters, emails, one-time diary and magazine, and a few others. I'd initially used MikTeX, while on windows, and then texlive distributions of TeX. The former has the standard windows issues: ugly, shitty, but still usable, UI⸻dl, click some boxes, click install, and whoop, it's done. texlive required more manhandling and a weird way of working with it. On the other hand, tectonic is a one-off binary, it installs any packages as needed without any fuss (of which there was plenty with texline); never interrupts execution to prompt for the in 99.9% of cases unneeded user input.

Filtering: rg, pcre2grep
grep sucks ass. POSIX sucks major donkey dick. Most often than not, otherwise would this list exist? Its BRE and ERE⸻why do these exist again, it's not 1979 anymore⸻, are clumsy and or insufficient for non-trivial queries. perl is actually part of many distributions, so why in the fuck is not PCRE the default?! Acquiring usable output with grep requires a slew of options, if not repeated calls, that is pipes, since the regex are shit. GNU sed and awk are single-use languages, have learning curves (in being different to most anything new for the past 30 years). Necessary evils at times, I'll give You that.
Ripgrep is the 'GOTTA GO FAST!' meme compared to the rest. Specifically more so than ag, the silver searcher. Its option set allows it to be a better it a better fgrep, and it's capability to handle PCRE is swell. Everything said about former is more or less true of the latter. My fallback chain is usually perl neat or (a lot of) zsh.

File search: fd
Vroom-vroom. Fast, sane regex. Fuck me, I despised GNU find. All said regarding rg more or less true of this too.

Fuzzy search: fzf, fzy
Latter has 10 times a lesser LoC, is faster and has better, saner matching. Former has had an ongoing feature creep since its inception. That said, the adjustable keybindings from outside the program at runtime, the preview-window, and bindable actions, formatting, multiple selections and some other bullshits allow creation of nice and intricate shell scripts, using it as a display (rather than as a search tool), and integration with other terminal programs. sk is the new kid on the block. Using the tranniest of languages, or due to maintainer's incompetence, it suffers significant lag for some operations compared to fzf. I'm going to edit fzy to add in whatever options I want from fzf, and call it a day.

RSS parser: sfeed
Small, easily extendable and customizable, cronable, supports various inputs and outputs. I made some keybinding adjustments, and two scripts, one for spritzing, and one for flite, both, as well as the default page open, get the rdrview treatment. The UI of sfeed_curses is nice enough.

Font: Fira Code
Not exactly software. I use it as my serif, sans serif, and monospaced fonts, that is, for literally everything. I used to, during my uni years, like very rounded sans serif fonts: Century Gothic, ITC Avant Garde Gothic, TeX Gyre Adventor, and Futura. These, however, hinder legibility at greater glyph throughtput and letter discrimination at a distance. The ligatures, programming-specific and others, are eye candy, that is, nice to oogle at.